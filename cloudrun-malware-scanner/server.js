/*
* Copyright 2021 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const busboy = require("express-busboy");
const clamd = require("clamdjs");
const express = require("express");
const fs = require("fs");
const { ApiError } = require("@google-cloud/common");
const { GoogleAuth } = require("google-auth-library");
const { logger } = require("./logger.js");
const pkgJson = require("./package.json");
const metrics = require("./metrics.js");

const PORT = process.env.PORT || 8080;
const CLAMD_HOST = "127.0.0.1";
const CLAMD_PORT = 3310;

// 10 min timeout for scanning.
const CLAMD_TIMEOUT = 600000;

// Create Clients.
const app = express();

//
//
// TODO: use a streaming multi-part API. Do not want to save the file to disk.
//
//
busboy.extend(app, { upload: true });

app.use(express.json());
const scanner = clamd.createScanner(CLAMD_HOST, CLAMD_PORT);

/**
 * Route that is invoked by Cloud Run when a malware scan is requested.
 *
 * For command line testing, use
 *
 * curl -d '{"kind": "storage#object","name":"sparse_file_1G", "bucket": "BUCKET_NAME" }' -H "Content-Type: application/json" http://localhost:8080
 *
 *
 * @param {!Request} req The request payload
 * @param {!Response} res The HTTP response object
 */
app.post("/", async (req, res) => {
  debugger;

  try {
    const file = req.files.file;
    const path = file.file;
    const basename = file.filename;
    const clamdVersion = await getClamVersion();
    logger.info(`scanning with clam ${clamdVersion}`);

    const startTime = Date.now();
    const readStream = fs.createReadStream(path);
    let result;
    try {
      result = await scanner.scanStream(readStream, CLAMD_TIMEOUT);
    } finally {
      // Ensure stream is destroyed in all situations to prevent any
      // resource leaks.
      readStream.destroy();
    }
    const scanDuration = Date.now() - startTime;

    if (clamd.isCleanReply(result)) {
      logger.info(`Scan status for ${basename}: CLEAN (in ${scanDuration} ms)`);
      metrics.writeScanClean(123, scanDuration, clamdVersion);

      // Respond to API client.
      res.json({ status: "clean", clam_version: clamdVersion });
    } else {
      logger.warn(
        `Scan status for ${basename}: INFECTED ${result} ( in ${scanDuration} ms)`
      );
      metrics.writeScanInfected(123, scanDuration, clamdVersion);

      // Respond to API client.
      res.json({
        message: result,
        status: "infected",
        result: result,
        clam_version: clamdVersion,
      });
    }
  } catch (e) {
    logger.error({ err: e }, `Exception when processing: %s`, e.message);

    // A 500 will cause Pubsub/EventArc to retry the event.
    let statusCode = 500;

    if (e instanceof ApiError && [403, 404].includes(e.code)) {
      // Permission denied/file not found can be raised by the stream reading
      // and by the object move. They cannot be retried, so respond
      // with success, but log the error.
      statusCode = 200;
    }

    handleErrorResponse(res, statusCode, e.message);
  }
});

/**
 * Trivial handler for get requests which returns the clam version.
 *
 * Use:
 * curl -D - -H "Authorization: Bearer $(gcloud auth print-identity-token)"  \
     CLOUD_RUN_APP_URL
 * @param {!Request} req
 * @param {!Response} res
 */
app.get("/", async (req, res) => {
  res
    .status(200)
    .type("text/plain")
    .send(
      `${pkgJson.name} version ${pkgJson.version}
Using Clam AV version: ${await getClamVersion()}

${pkgJson.description}
(Responds to POST requests containing a GCS object only)

`
    );
});

/**
 * Respond with an error and log the message
 *
 * Note: any non-successful status codes will cause the caller (PubSub/Eventarc)
 * to retry sending the event, so use 200 for non-retryable errors.
 *
 * @param {Object} res response object
 * @param {number} statusCode
 * @param {string} errorMessage
 * @param {string=} unscannedBucket
 */
function handleErrorResponse(
  res,
  statusCode,
  errorMessage,
  unscannedBucket = /** @type {string} */ null
) {
  logger.error(`Error processing request: ${errorMessage}`);
  res.status(statusCode).json({ message: errorMessage, status: "error" });
  metrics.writeScanFailed();
}

/**
 * Wrapper to get a clean string with the version of CLAM.
 * @return {Promise<string>}
 */
async function getClamVersion() {
  return (await clamd.version(CLAMD_HOST, CLAMD_PORT)).replace("\x00", "");
}

/**
 * Perform async setup and start the app.
 */
async function run() {
  let projectId = process.env.PROJECT_ID;
  if (!projectId) {
    // Metrics needs project ID, so get it from GoogleAuth
    projectId = await new GoogleAuth().getProjectId();
  }
  await metrics.init(projectId);

  app.listen(PORT, () => {
    logger.info(
      `${pkgJson.name} version ${pkgJson.version} started on port ${PORT}`
    );
  });
}

// Start the service, exiting on error.
run().catch((e) => {
  logger.fatal(e);
  logger.fatal("Exiting");
  process.exit(1);
});
